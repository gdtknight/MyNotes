---
id: "[혼공단] '혼자 공부하는 컴퓨터 구조 + 운영체제' 4주차"
aliases:
  - "[혼공단] '혼자 공부하는 컴퓨터 구조 + 운영체제' 4주차"
tags:
  - 혼공단
  - CS
---

# [혼공단] '혼자 공부하는 컴퓨터 구조 + 운영체제' 4주차

## Chap 09. 운영체제 시작하기

### 09-1. 운영체제를 알아야 하는 이유

#### 운영체제란

- 실행할 프로그램에 필요한 자원 할당, 관리 및 프로그램 실행 지원
- 컴퓨터 부팅시 메모리 내 `커널 영역(kernel space)` 적재 <-> `사용자 영역(user space)` 사용자 프로그램 적재

#### 운영체제를 알아야 하는 이유

### 09-2. 운영체제의 큰 그림

#### 운영체제의 심장  커널

- `커널(kernel)` : 운영체제 핵심 서비스 담당
    - `사용자 인터페이스(UI; ex. GUI, CLI)` 는 운영체제가 제공하는 서비스이지만 커널에 포함되지 않음

#### 이중 모드와 시스템 호출

- `이중 모드(dual mode)` : CPU의 명령어 실행 모드.
    - `사용자 모드(user mode)` : 운영체제 서비스를 제공받을 수 없음
    - `커널 모드(kernel mode)` : `시스템 호출(System call)`*을 통해 운영체제 서비스를 제공받을 수 있음

* `시스템 호출(System call)` : 소프트웨어 인터럽트의 일종

#### 운영체제의 핵심 서비스

##### 프로세스 관리

- `프로세스(Process)` : 실행 중인 프로그램
- 운영체제는 여러 프로세스들의 실행하고 상태를 관리함

##### 자원 접근 및 할당

- `CPU` : 여러 프로세스들의 CPU 사용 관리  ->  `CPU scheduling`
- `Memory` : 새로운 프로세스 실행시 메모리 적재, 메모리가 부족한 경우의 처리 등 메모리 관리
- `I/O Device` : 입출력 장치가 CPU 에 하드웨어 인터럽트 요청 시그널을 보내는 경우 CPU 는 운영체제의 커널 영역에 있는 `인터럽트 서비스 루틴` 실행.

##### 파일 시스템 관리

- 보조기억장치에 데이터를 생성, 삭제, 접근 등의 서비스 제공 -> `파일 시스템(File system)`


## Chap 10. 프로세스와 스레드

### 10-1. 프로세스 개요

#### 프로세스 직접 확인하기

- `윈도우` : 작업 관리자 /  `유닉스` : `ps` 명령어
- `foreground process` : 사용자가 보는 앞에서 실행되는 프로세스
- `background process` : 사용자가 볼 수 없지만 실행 중인 프로세스
    - `daemon` : 사용자와 상호 작용 없이 정해진 일만 수행. (윈도우 계열 -> `service`)

#### 프로세스 제어 블록 (Process Control Block; PCB)

- 운영체제가 프로세스 실행 순서, 프로세스별 할당 자원 관리 등을 위해 프로세스 관련 정보를 저장하는 자료 구조
- `PCB` 에 담기는 정보
     - `Process ID`
     - `Register Value`
     - `Process Status`
     - `CPU Scheduling Info`
     - `Memory Info`
     - `File / IO Device Info`

#### 문맥 교환

- 기존 프로세스의 `문맥(context)`*을 `PCB`에 백업하고 새로운 프로세스를 실행하기 위한 `문맥`을 `PCB`로부터 복구하여 새로운 프로세스를 실행하는 것

* `문맥(Context)` : 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보 -> `PCB` 에 기록

#### 프로세스의 메모리 영역

##### 코드 영역(Code Segment)

- `텍스트 영역(text segment)` 라고도 부름
- `CPU가 실행할 명령어 (기계어)` 저장
- `읽기 전용` 공간. (CPU가 실행할 명령어가 저장되므로 쓰기 금지)

##### 데이터 영역(Data Segment)

- 프로그램이 실행되는 동안 **유지될 데이터**(ex. 전역 변수 등)가 저장되는 영역
- `코드 영역`과 더불어 **크기가 고정되어 있는 `정적 할당 영역`**
    <-> `힙 영역`, `스택 영역` 크기가 변하는 `동적 할당 영역`

##### 힙 영역(Heap Segment)

- 프로그래머가 직접 할당하고 해제할 수 있는 저장 공간
- 사용이 끝난 공간을 할당 해제(반환) 하지 않을 경우 `메모리 누수(Memory leak)` 발생

##### 스택 영역(Stack Segment)

- 데이터를 일시적으로 저장하는 공간
- `매개 변수`, `지역 변수` 등이 저장되는 공간

### 10-2. 프로세스 상태와 계층 구조

#### 프로세스 상태

- `생성 상태(New)`
- `준비 상태(Ready)`
- `실행 상태(Running)`
- `대기 상태(Blocked)`
- `종료 상태(Terminated)`

#### 프로세스 계층 구조

- 시스템 호출(ex. `fork()`, `exec()`) 을 통해 실행 도중 다른 프로세스 생성 가능
    - `부모 프로세스(Parent Process)` : 시스템 콜을 사용한 프로세스
    - `자식 프로세스(Child Process)` : 시스템 콜에 의해 새로 생성된 프로세스

- `프로세스 계층 구조` : 생성된 프로세스 간의 관계를 나타낸 것 -> `pstree` 명령을 통해 확인가능

* 최초의 프로세스 : `init` (Unix 계열), `systemd`(Linux 계열), `launchd`(macOS 계열).

#### 프로세스 생성 기법

- `fork()` 를 통해 프로세스 복제 ->  `exec()`를 통해 생성된 프로세스의 메모리 공간을 다른 프로그램으로 덮어씀

### 10-3. 스레드

#### 프로세스와 스레드

- `스레드(Thread)` : `프로세스`를 구성하는 실행의 흐름 단위
    - `단일 스레드 프로세스` : 프로세스를 구성하는 실행 흐름 단위가 하나
    - 실행에 필요한 최소한의 정보(프로그램 카운터를 포함하는 레지스터  스택)만을 유지한 채 프로세스 자원을 공유하며 실행

#### 멀티프로세스와 멀티스레드

- `멀티프로세스` : 여러 프로세스를 동시에 실행하는 것
- `멀티스레드` : 여러 스레드로 한 프로세스를 동시에 실행하는 것

- 둘 이상의 작업이 동일한 데이터에 대한 접근이 필요한 경우 `멀티스레드`가 `멀티 프로세스`에 비해 더 유리함


## Chap 11. CPU 스케쥴링

### 11-1. CPU 스케쥴링 개요

#### 프로세스 우선순위 (Process Priority)

- `한정된 자원(CPU)`을 공정하고 효율적으로 사용하기 위해 각 프로세스에 `우선순위`를 부여함.
- 프로세스 구분
    - `입출력 집중 프로세스 (I/O bound process)` -> `I/O burst`
    - `CPU 집중 프로세스 (CPU bound process)` -> `CPU burst`

- `Unix` 계열 -> `ps -el` 명령 : 프로세스 우선순위 확인 / `nice` 명령 : 프로세스 우선순위 변경.

#### 스케쥴링 큐

- PCB에 기록된 우선순위 확인을 위해 모든 프로세스의 PCB를 확인하는 것은 비효율적
- 운영체제는 `스케쥴링 큐(Scheduling queue)` 를 통해 우선순위에 따라 각 프로세스를 관리.
    - `준비 큐(ready queue)`, `대기 큐(waiting queue)`, ...

#### 선점형과 비선점형 스케쥴링

##### 선점형 스케쥴링(Preemptive Scheduling)

- 특정 프로세스가 CPU를 비롯한 **자원을 사용하고 있어도 운영체제가 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케쥴링 방식**
- 특정 프로세스의 자원 독점 방지 가능
- 문맥 교환 (Context Switching) 과정에서 오버헤드 발생

##### 비선점형 스케쥴링(Non-preemptive Scheduling)

- **자원을 사용 중인 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지 다른 프로세스가 끼어들 수 없는 스케쥴링 방식**
- 문맥 교환 횟수가 상대적으로 적기 때문에 오버헤드가 감소됨
- 특정 프로세스의 자원 독점으로 인해 다른 프로세스의 대기 시간이 길어질 수 있음.


### 11-2. CPU 스케쥴링 알고리즘

#### 스케쥴링 알고리즘의 종류

##### 선입 선처리 스케쥴링 (FCFS; First Come First Served Scheduling)

- 준비  큐에 삽입된 순서대로 프로세스 처리 / 비선점형 스케쥴링
- 앞선 프로세스들의 CPU 사용시간이 길 경우 현재 프로세스 처리 시간에 관계없이 긴 시간을 기다리게 됨 (`호위 효과(convoy effect)`)

##### 최단 작업 우선 스케쥴링 (SJF; Shortest Job First Scheduling)

- `호위 효과`를 방지하기 위해 작업 시간이 빠른 프로세스들부터 우선적으로 실행
- 기본적으로 `비선점형 스케쥴링` -> `선점형` 으로 구현한 것이 `최소 잔여 시간 우선 스케쥴링`

##### 라운드 로빈 스케쥴링 (Round Robin Scheduling)

- `선점형 스케쥴링`
- `FCFS` + `Time slice`
- `Time slice` : 각 프로세스가 CPU를 사용할 수 있는 시간

##### 최소 잔여 시간 우선 스케쥴링 (SRT; Shortest Remaining Time Scheduling)

- `SJF` + `Round-robin`.
- 남아 있는 작업 시간이 가장 작은 프로세스가 다음에 처리할 프로세스로 선택됨

##### 우선순위 스케쥴링 (Priority scheduling)

- 프로세스에 `우선순위` 부여 후 가장 높은 우선순위의 프로세스부터 실행
- 넓은 의미에서 `SJF`, `SRT` 도 포함 가능
- `기아(Starvation)`현상 : 우선순위가 낮은 프로세스의 실행이 계속 뒤로 연기되어 실행되지 않는 현상
- `에이징(Aging)` : 오랫동안 대기한 프로세스 우선순위를 점차 높여 `기아` 방지

##### 다단계 큐 스케쥴링 (Multilevel queue scheduling)

- 준비큐를 우선순위 별로 여러개 사용
- 각 준비큐마다 타임 슬라이스를 별도로 지정하거나 서로 다른 스케쥴링 알고리즘 적용 가능

##### 다단계 피드백 큐 (multilevel feedback queue scheduling) 스케쥴링

- `다단계 큐 스케쥴링` 에서 프로세스들은 다른 큐로 이동할 수 없음 -> `기아 현상` 여전히 발생 가능
- `준비 상태` 프로세스는 가장 높은 우선순위 큐에 삽입 후 일정 시간(`타임 슬라이스`)동안 실행
- 실행이 완료되지 않은 경우 다음 우선순위 큐에 삽입되고 `타임 슬라이스` 동안 실행
- `CPU 집중 프로세스`들의 우선순위는 점차 낮아짐 / `IO 집중 프로세스`들은높은 우선순위에서 실행 종료
- 구현이 복잡하나 가장 일반적인 CPU 스케쥴링 알고리즘

---

## 4주차 숙제

### (p. 304) 확인 문제 1번

#### Q. 프로세스 상태 다이어그램에 1 ~ 5 까지 올바른 상태를 적어보세요
```

#### A.

    1. 생성 상태
    2. 준비 상태
    3. 실행 상태
    4. 종료 상태
    5. 대기 상태

---

### 추가 숙제

#### Q. 준비 큐에 A,B,C,D 순으로 삽입되었다고 가정했을 때, 선입 선처리 스케줄링 알고리즘을 적용하면 어떤 프로세스 순서대로 CPU를 할당받는지 풀어보기

#### A.

- 비선점형 스케쥴링에 해당하고 준비큐에 먼저 삽입된 순서대로 처리되므로 작업 시간에 상관 없이 `A, B, C, D` 순으로 차례대로 처리된다.
