---
id: "[혼공단] '혼자 공부하는 컴퓨터 구조 + 운영체제' 6주차"
aliases:
  - "[혼공단] '혼자 공부하는 컴퓨터 구조 + 운영체제' 6주차"
tags:
  - 혼공단
  - CS
---

# [혼공단] '혼자 공부하는 컴퓨터 구조 + 운영체제' 6주차

## Chapter 14. 가상 메모리

### 14-1. 연속 메모리 할당

- `연속 메모리 할당` : 메모리 공간에 프로세스들을 연속적으로 배치 -> `외부 단편화` 발생

#### 스와핑

- 메모리에 적재된 프로세스 중 현재 실행되지 않는 프로세스를 보조 기억 장치로 옮기고, 메모리상 빈 공간에 다른 프로세스를 적재하여 실행하는 방식

\* `스왑 영역(swap space)` : 실행되지 않는 프로세스들이 임시로 적재되는 보조기억장치 일부 영역
    \* `스왑 아웃(swap-out)` : 프로세스를 메모리에서 스왑 영역으로 옮기는 것
    \* `스왑 인(swap-in)` : 프로세스를 스왑 영역에서 다시 메모리로 옮겨오는 것
- 프로세스들이 요구하는 메모리 영역의 합이 실제 메모리보다 큰 경우에도 프로세스 동시 실행이 가능


#### 메모리 할당

- 스왑 중에 생기는 메모리 빈 공간 중 어느 곳에 프로세스를 배치할지 결정하는 것

##### 최초 적합(first fit)

- 운영체제가 메모리 내 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하는 그 즉시 해당 공간에 프로세스를 배치
- 검색시간 최소화로 메모리의 빠른 할당이 가능

##### 최적 적합(best fit)

- 메모리 전체 빈 공간을 검색한 후 프로세스가 적재될 수 있는 공간 중 가장 작은 크기의 공간에 해당 프로세스 배치

##### 최악 적합(worst fit)

- 메모리 전체 빈 공간을 검색한 후 프로세스가 적재될 수 있는 공간 중 가장 큰 크기의 공간에 해당 프로세스 배치


#### 외부 단편화

- 아래 예제에서 총 `30MB` 의 여유 공간이 있지만 `30MB` 프로세스는 할당 불가능

  1. 메모리 내 사용자 공간은 총 `50MB` 이고 현재 `5MB` ~ `25MB` 프로세스가 메모리에 연속적으로 할당된 상태

|메모리 내 사용자 공간 (총 50mb)|
|:---:|
|5mb process|
|10mb process|
|15mb process|
|20mb process|
|25mb process|

  2.  `10MB` `20MB` 프로세스 실행이 완료되어 메모리 해제

|메모리 내 사용자 공간 (총 50mb)|
|:---:|
|5mb process|
|***empty space (10mb)***|
|15mb process|
|***empty space (20mb)***|
|25mb process|


### 14-2. 페이징을 통한 가상 메모리 관리

#### 페이징이란

- 메모리, 프로세스를 일정한 단위로 자르고 (`프로세스 : 페이지`, `메모리 : 프레임`) 이를 메모리에 불연속적으로 할당가능하도록 만들어 `외부 단편화`*로 인한 메모리 낭비 방지

\* `외부 단편화` 를 해결할 수 있으나, 반대로 `내부 단편화`** 발생 가능
\*\*  `내부 단편화` : 전체 프로세스 크기가 페이지 크기의 배수가 아닐 경우 마지막 페이지에 남는 공간이 발생할 수 있음. 예를 들어, 페이지 크기가 `10kb`이고, 프로세스 크기가 `108kb` 인 경우 마지막 페이지에 `2kb` 만큼 메모리 낭비 발생


#### 페이지 테이블

- `페이지 테이블` : 현재 어떤 `페이지`가 어떤 `프레임`에 할당되었는지 저장하는 자료 구조
- `페이지 테이블 베이스 레지스터(PTBR; page table base register)` : 각 프로세스의 페이지 테이블이 적재된 주소를 가리키는 레지스터

\* `페이지 테이블`을 메모리에 둘 경우 메모리 접근 시간이 두 배로 늘어남. 이를 해결하기 위해 `TLB(translation lookaside buffer)`** 이용
\*\* `TLB` : 캐시 메모리의 일종. `참조 지역성`에 근거하여 최근에 접근한 페이지 테이블의 일부 내용을 캐시로 저장.


#### 페이징에서의 주소 변환

- 특정 주소에 접근하기 위해 필요한 정보
  - 어떤 페이지 (혹은 프레임)에 접근하고 싶은지
  - 접근하려는 주소가 그 페이지 (혹은 프레임)으로부터 얼마나 떨어져 있는지
- 이를 위해 `페이징 시스템`에서 모든 주소는 `페이지 번호`, `변위(오프셋;offset)` 으로 구성


#### 페이지 테이블 엔트리

- `페이지 테이블 엔트리(PTE; page table entry)` : 페이지 테이블에서 각각의 행
- `PTE`에 저장되는 정보
  - `페이지 번호`
  - `프레임 번호`
  - `유효 비트` : *현재 해당 페이지에 접근 가능한지*
  - `보호 비트` : *해당 페이지가 읽기만 가능한지 혹은 읽고 쓰기 모두 가능한지*
  - `참조 비트` : CPU 가 이 페이지에 접근한 적이 있는지
  - `수정 비트` : 페이지가 메모리에서 사라질 때 보조 기억 장치에 쓰기가 필요한지


#### \[좀 더 알아보기\] 페이징의 이점 - 쓰기 시 복사

- `fork()` 함수가 호출되는 경우 자식 프로세스에게 별도의 메모리 공간이 할당되어야 함.
- 실제로 메모리 내용을 덮어쓰기 전까지는 자식 프로세스를 위한 별도의 페이지 테이블만 생성되고,  해당 페이지 테이블의 페이지들은 부모와 동일한 프레임을 가리키고 있음.
- 이를 통해 자식 프로세스가 좀 더 빨리 준비될 수 있고, 메모리 공간의 낭비를 막을 수 있음.


#### \[좀 더 알아보기\] 계층적 페이징

- `페이지 테이블` 을 페이징. 즉, 여러 단계의 페이지를 두는 방식
- `다단계 페이지 테이블(multilevel page table)`
- 다단계 페이지 테이블에서 논리 주소 형태

| 바깥 페이지 번호 | 안쪽 페이지 번호 | 변위 |
|:----------------:|:----------------:|:----:|

  1. `바깥 페이지 번호`를 통해 `페이지 테이블의 페이지` 검색
  2. `페이지 테이블 페이지`를 통해 `프레임 번호`를 찾고 `변위`를 더하여 물리 주소 변환


### 14-3. 페이지 교체와 프레임 할당

#### 요구 페이징

- 프로세스에서 현재 필요한 페이지만을 메모리에 적재하는 기법. 즉, <u>실행에 요구되는 페이지만 적재</u>

- 기본 흐름 (ex. `순수 요구 페이징(pure demand paging)`)
  1. CPU가 특정 페이지에 접근하는 명령어 실행
  2. 해당 페이지가 메모리에 존재하는 경우(유효 비트 `1`) CPU는 페이지가 적재된 프레임에 접근
  3. 해당 페이지가 메모리에 존재하지 않는 경우(유효 비트 `0`) 페이지 폴트 발생
  4. `페이지 폴트 처리 루틴`에서 페이지 적재 후 유효 비트 `1` 로 설정
  5. 다시 `1번` 수행

- 요구 페이징 시스템의 고려사항
  1. 페이지 교체 (페이지 교체 알고리즘)
  2. 프레임 할당


#### 페이지 교체 알고리즘

##### FIFO 페이지 교체 알고리즘

- 메모리에 `가장 먼저 적재된 페이지`부터 교체

\* 2차 기회 페이지 교체 알고리즘
  FIFO 알고리즘 적용시 자주 참조되는 페이지임에도 먼저 참조되었다는 이유로 교체 당할 수 있음. FIFO를 통해 선택된 페이지 참조 비트가 1일 경우 참조 비트를 0으로 만들고 현재 시간을 적재 시간으로 설정. 참조 비트가 0인 상태에서 FIFO를 통해 선택되는 경우 그대로 교체

##### 최적 페이지 교체 알고리즘

- 앞으로 오랫동안 사용되지 않을 페이지를 교체
- `앞으로 오랫동안 사용되지 않을 페이지` 예측이 어려우므로, 실제 사용보다는 다른 알고리즘의 이론상 성능 평가 목적으로 사용

##### LRU 페이지 교체 알고리즘

- `LRU` : Least Recently Used Page Replacement Algorithm
- `가장 오랫동안 사용되지 않은 페이지`를 교체


#### 스레싱과 프레임 할당

##### 스래싱(thrashing)

- 프로세스가 실제 실행되는 시간보다 페이징에 소요되는 시간이 더 많아서 성능이 저해되는 문제
  (예) 사용 가능한 프레임 수가 너무 적어서 페이지 폴트 빈도가 높아지는 경우 -> `멀티프로그래밍 정도(degree of multiprogramming)` 를 높인다고 해서 CPU 이용률이 비례해서 증가하지 않음

- 프레임 할당 방식 (정적 할당 방식; 프로세스 실행 과정 고려 X, 오직 프로세스 크기, 물리 메모리 크기만 고려)

  - `균등 할당(equal allocation)`
  - `비례 할당(proportional allocation)`

- 동적 할당 방식(프로세스 실행 과정에서 배분할 프레임 결정)

  - `작업 집합 모델(working set model)`
    프로세스가 일정 기간 동안 참조한 페이지 집합(작업 집합; working set)을 기억
  - `페이지 폴트 빈도(PFF; page-fault frequency)`
    페이지 폴트율의 상한, 하한을 정해서 이 범위 안에서 프레임 할당


## Chapter 15. 파일 시스템

### 15-1. 파일과 디렉토리

#### 파일

- 보조기억장치(HDD, SSD 등)에 저장된 관련 정보의 집합
- 이름, 실행을 위한 정보 및 파일 관련 부가 정보* 포함

\* 메타데이터(metadata; 속성;  attribute)

##### 파일 속성과 유형

| 속성 이름        | 의미                                     |
|:-----------------|:-----------------------------------------|
| 유형             | 운영체제가 인지하는 파일의 종류(확장자)  |
| 크기             | 파일의 현재 크기,  허용 가능한 최대 크기 |
| 보호             | 사용자별 파일 권한(읽기, 쓰기, 실행)     |
| 생성 날짜        | 파일이 생성된 날짜                       |
| 마지막 접근 날짜 | 파일에 마지막으로 접근한 날짜            |
| 마지막 수정 날짜 | 파일이 마지막으로 수정된 날짜            |
| 생성자           | 파일을 생성한 사용자                     |
| 소유자           | 파일을 소유한 사용자                     |
| 위치             | 파일의 보조기억장치상 현재 위치          |

##### 파일 연산을 위한 시스템 호출

- 파일 관련 모든 작업은 운영체제에 의해서만 이루어짐
- 응용 프로그램은 `시스템 콜` 을 통해 필요한 작업들을 운영체제에 요청


#### 디렉토리 (윈도우 - 폴더)

- 파일 관리를 위해 도입
- `1단계 디렉토리`가 발전하여 현재의 `트리 구조 디렉토리`로 발전

##### 절대 경로와 상대 경로

- `절대 경로` : 최상위 루트 디렉토리를 기준으로 나타낸 파일 경로
- `상대 경로` : 현재 디렉토리를 기준으로 나타낸 파일 경로

##### 디렉토리 연산을 위한 시스템 호출

- 파일과 마찬가지로 운영체제(시스템 콜) 에 의해서 수행

##### 디렉토리 엔트리

- 운영체제는 디렉토리를 `특별한 형태의 파일`로 간주
- `디렉토리 엔트리` : 해당 디렉토리에 포함되는 대상 관련 정보를 저장하는 테이블


#### \[좀 더 알아보기\] 상대 경로를 나타내는 또 다른 방법

- `.` : 현재 디렉토리
- `..` : 현재 디렉토리의 한단계 상위 디렉토리


### 15-2. 파일 시스템

- `파일 시스템` : 파일, 디렉토리를 보조기억장치에 저장하고 접근할 수 있게 하는 운영체제 내부 프로그램

#### 파티셔닝과 포매팅

- `파티셔닝` : 저장 장치의 논리적인 영역을 구획하는 작업
  - `파티션` : 파티셔닝을 통해 나누어진 각 영역
- `포매팅` : 파일 시스템을 생성하여 저장 장치에 새로운 데이터를 쓰기 위한 준비 작업
  - `저수준 포매팅` : 저장 장치 생성 당시 공장에서 수행되는 물리적 포매팅


#### 파일 할당 방법

- `블록(Block)` : 운영체제가 저장 장치에 파일, 디렉토리를 읽고 쓰는 단위
  하드 디스크의 가장 작은 단위는 섹터이지만, 섹터 단위로 관리하기엔 크기가 너무 작고 개수는 너무 많음
  (윈도우에서는 `클러스터`)

- 파일에 블록을 할당하는 방법 : `연속 할당`, `불연속 할당` - `연결 할당`, `색인 할당`

##### 연속 할당 (contiguous allocation)

- 연속적으로 할당
- `외부 단편화` 발생하므로 비효율적


##### 연결 할당 (linked allocation)

- 각 `블록` 의 일부에 `다음 블록의 주소`를 저장
- 반드시 첫번째 블록부터 하나씩 읽어야 함
- 하드웨어 고장이나 오류 발생 시 해당 블록 이후 블록에 접근 불가
- 연결 할당을 변형한 대표적인 파일 시스템이 `FAT`


##### 색인 할당 (indexed allocation)

- 파일의 모든 블록 주소를 `색인 블록(index block)` 에 모아서 관리하는 방식
- 파일 내 임의 위치에 대한 접근 용이
- 색인 할당 사용시 `디렉토리 엔트리`에 파일 이름과 `색인 블록 주소`를 함께 명시
- `유닉스 파일 시스템`이 대표적


#### 파일 시스템 살펴보기

##### FAT 파일 시스템

|예약영역|FAT 영역|루트 디렉토리 영역|데이터 영역|
|:------:|:------:|:----------------:|:---------:|

- `파일 할당 테이블(FAT; file allocation table)` : 각 블록에 포함된 다음 블록 주소들을 관리하는 테이블
- `FAT`를 메모리에 적재하고 실행시 임의 접근 성능 개선
- `FAT 파일 시스템` 의 디렉토리 엔트리

|파일명|확장자|속성|예약영역|생성시간|마지막접근시간|마지막수정시간|시작블록|파일크기|
|:----:|:----:|:--:|:------:|:------:|:------------:|:------------:|:------:|:------:|


##### 유닉스 파일 시스템

|예약영역|i-node 영역|데이터 영역|
|:------:|:---------:|:---------:|

- `i-node` : 유닉스에서 사용되는 색인 블록의 명칭. `파일 속성 정보`와 `열다섯 개의 블록 주소` 저장 가능
  - 파일마다 번호가 부여된 `i-node`가 존재.
  - `i-node` 의 블록 주소 공간 중 **첫 12개**는 **데이터 블록 주소** 직접 명시.
  - **13번째** 공간은 `단일 간접 블록` 주소 저장
  - **14번째** 공간은 `이중 간접 블록`* 주소 저장
  - **13번째** 공간은 `삼중 간접 블록`** 주소 저장

\* `이중 간접 블록` : `단일 간접 블록`들의 주소를 저장
\*\* `삼중 간접 블록` :  `이중 간접 블록`들의 주소를 저장

- 유닉스 파일 시스템의 디렉토리 엔트리

|i-node 번호|파일이름|
|:---------:|:------:|


#### \[좀 더 알아보기\] 저널링 파일 시스템

- `저널링 기법`* 을 이용한 파일 시스템
  - 파일 시스템 변경 도중 시스템 크래시 등에서 빠른 복구 가능

\* `저널링 기법` : 작업 로그를 먼저 남긴 후 작업을 수행하고 작업이 끝나면 로그를 삭제함. 작업 수행 중 에러 발생으로 작업이 정상적으로 완료되지 못한 경우 로그를 통해 복구 가능


#### \[좀 더 알아보기\] 마운트

- 한 저장 장치의 파일 시스템에서 다른 저장 장치의 파일 시스템에 접근할 수 있도록 파일 시스템을 편입시키는 작업

---

## 6주차 숙제

### (p. 400) 확인 문제 1번

#### Q. 메모리 할당 방식에 대한 설명으로 올바른 것을 다음 보기에서 찾아 써 보세요.

```markdown
[보기] 최초 적합, 최적 적합, 최악 적합
```
- `(   1   )` : 최초로 발견한 적재 가능한 빈 공간에 프로세스를 배치하는 방식
- `(   2   )` : 프로세스가 적재될 수 있는 가장 큰 공간에 프로세스를 배치하는 방식
- `(   3   )` : 프로세스가 적재될 수 있는 가장 작은 공간에 프로세스를 배치하는 방식

#### A. 

- `(   1   )` : 최초 적합
- `(   2   )` : 최악 적합
- `(   3   )` : 최적 적합

---

### (추가 숙제) Ch.14 (14-3)

#### Q. 프로세스가 사용할 수 있는 프레임이 3개 있고, 페이지 참조열이 '2313523423' 일 때 LRU 페이지 교체 알고리즘으로 이 페이지를 참조한다면 몇 번의 페이지 폴트가 발생하는가?

#### A. 총 6번 발생

- 참조열 순서대로 서술

01.  `2`번 페이지 참조 시도  -  ***페이지 폴트!*** `2`번 페이지 적재

| 프레임 구분 |   1   |   2   |   3   |
|:-----------:|:-----:|:-----:|:-----:|
| 적재 페이지 |   **2**   |       |       |
|  접근 시기  |   **1**   |       |       |

02.  `3`번 페이지 참조 시도  -  ***페이지 폴트!***  `3`번 페이지 적재

|프레임 구분|  1  |  2  |  3  |
|:-----------:|:-----:|:-----:|:-----:|
|적재 페이지|  2  |  **3**  |     |
|접근 시기  |  1  |  **2**  |     |

03.  `1`번 페이지 참조 시도  -  ***페이지 폴트!***  `1`번 페이지 적재

|프레임 구분|  1  |  2  |  3  |
|:-----------:|:-----:|:-----:|:-----:|
|적재 페이지|  2  |  3  |  **1**  |
|접근 시기  |  1  |  2  |  **3**  |

04.  `3`번 페이지 참조 시도  -  `2`번 프레임 접근

|프레임 구분|  1  |  2  |  3  |
|:-----------:|:-----:|:-----:|:-----:|
|적재 페이지|  2  |  **3**  |  1  |
|접근 시기  |  1  |  **4**  |  3  |

05.  `5`번 페이지 참조 시도  -  ***페이지 폴트!*** `1`번 프레임이 가장 오래전에 접근했으므로 페이지 교체

|프레임 구분|  1  |  2  |  3  |
|:-----------:|:-----:|:-----:|:-----:|
|적재 페이지|  **5**  |  3  |  1  |
|접근 시기  |  **5**  |  4  |  3  |

06.  `2`번 페이지 참조 시도 - ***페이지 폴트!*** `3`번 프레임이 가장 오래전에 접근했으므로 페이지 교체

|프레임 구분|  1  |  2  |  3  |
|:-----------:|:-----:|:-----:|:-----:|
|적재 페이지|  5  |  3  |  **2**  |
|접근 시기  |  5  |  4  |  **6**  |

07.  `3`번 페이지 참조 시도  -  `2`번 프레임 접근

|프레임 구분|  1  |  2  |  3  |
|:-----------:|:-----:|:-----:|:-----:|
|적재 페이지|  5  |  3  |  2  |
|접근 시기  |  5  |  **7**  |  6  |

08.  `4`번 페이지 참조 시도 - ***페이지 폴트!***  `1`번 프레임이 가장 오래전에 접근했으므로 페이지 교체

|프레임 구분|  1  |  2  |  3  |
|:-----------:|:-----:|:-----:|:-----:|
|적재 페이지|  **4**  |  3  |  2  |
|접근 시기  |  **8**  |  7  |  6  |

09.  `2`번 페이지 참조 시도 - `3`번 프레임 접근

|프레임 구분|  1  |  2  |  3  |
|:-----------:|:-----:|:-----:|:-----:|
|적재 페이지|  4  |  3  |  **2**  |
|접근 시기  |  8  |  7  |  **9**  |

10.  `3`번 페이지 참조 시도 - `2`번 프레임 접근

|프레임 구분|  1  |  2  |  3  |
|:-----------:|:-----:|:-----:|:-----:|
|적재 페이지|  4  |  **3**  |  2  |
|접근 시기  |  8  |  **10**  |  9  |
